Сделать узел доната.


Ныадо подумать над вьювером текста, да и вообще над данными, ты говорил про деревья данных. Так вот, самый низкий уровень вложения должен быть таким [ вершина, вершина,... ]
А самого низкого не должно быть. Но у меня во вьювере не верная нумерация. Вернее, вообще с данными надо подумать. ведь могут быть подуровни, значит их тоже надо обозначит, значит надо нащупывать дно каждый раз, проверять иерархию. И написать дефинишн, который нащупывает дно и говорит всем другим дефинициям сколько итераций надо провести чтобы добраться до данных. Тогда как бы глубоко не были зарыты данные, их всегда можно отрыть
12:26:38	
и во вьювере прорисовать независимо от вложенности и в текстовом вьювере показать количество вложенностей и написать все значения, как они есть, то есть если данные глубже, то не будет всё в одну строчку, а будет
==0==0==
(0,0,0)...
==0==1==
(0,0,0)...
и каждый уровень добавляет свой n== в заглавие, соответственно тому, где вложено
вот сейчас буду делать сочленитель списков
и там надо будет продумать все варианты соединения, вот пример:
соединяем списки вершин, и затем соединяем их линиями. Как поступить? Ведь вершины расположены последовательно, значит общего списка не выйдет, а мы хотим разделить линии и вершины. То есть, нам надо вложить уровень, который бы разделял вершины, пришедшие от разных списков. Соединитель их должен воспринимать как один объект! И соединять с разрывом именно в месте их соединения! Это текстово выглядит так:
[ [ verts1 ] ] + [ [ verts2 ] ] = [ [ [ verts1 ] [ verts2 ] ] ] 
то есть, первый уровень - контейнер, второй объект, а вот третий уже изначально берётся как данные и в нём уже ищется вложенность, всё что больше 3 скобок подвергается сомнению
12:34:35	
или обратный пример.
[ [ verts1 ] ] => [ vert1, vert2, vert3, vert4, ... ] где каждая вершина становится объектом. Этого не надо допускать, т.к. понятие объекта должно сохраняться для последующего сочетания с матрицей мира. в таком случае надо вложить каждую вершину в свой список
[ [ vert1 ], [ vert2 ], ... ]
но иногда нужны персональные вершины для каждого объекта, если мы используем векторы (а вершины у нас и есть векторы) для перемещения объекта.


Объединить Viewer_draw + Object_out и при нажатии кнопки сделать запекание "bake" в объекты блендера
ни то как-то грамоздко всё.

Утилитарная вещь, нужно сделать дефиницию, определяющую длинну списков и выводящую последовательно списки в порядке убывания длинны. При том, она должна уметь это делать на любом указанном уровне,

Чтобы определить уровень, нужна другая дефиниция, возвращающая вложенность списка, определять она будет, наверное итерацией первого объекта, потому что в списке должны быть все элементы одного уровня, иначе список галимый.

соединитель списков не фонтан. соединять списки надо тремя способами -

в цельный список
в список по рядам
в список по столбцам, вот например по столбцам мне не хватает, чтобы смонтировать геометрию. кстати, очень помогает lisl levels узел, реально. только в него надо вводить [0,1,2]

def tree_update():
    for ng in bpy.context.blend_data.node_groups:
        ng.interface_update(bpy.context)
    return

нужны батарейки - длинна списка, сортировка списка, переворачивание внутри уровней. надо доработать объединитель списков. Доработать деформацию матрицы.


добавить узел удаления по маске pop-remove.
и разделения списков, а может совместить в одном флаконе.