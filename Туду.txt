ТУДУшечка.
дополняется снизу.
    
решено. Проблема. У нас есть списки:
        А                              Б
# 0 socket data a                   socket data b
# 1 [ object a ]                    [ object b ]
# 2 object a = [i,i,i,i,i ]         object b = [k,k,k,k,k ]
# 3 i = [n,n,n,n,n]                 k = [a,a,a,a,a]
# 4 n = integer                     a = integer

надо соединить так, чтобы получилось при уровне вложенности 1:
    АБ
# [ object a ],[ object b ]                                     
# object a = [i,i,i,i,i ]   
# i = [n,n,n,n,n]         
# n = integer

при уровне вложенности 2:
    АБ                                                            с подсписком:
# [ object ab ]                                                 [ list a ],[ list b ]
# object ab = [i,i,i,i,i ,k,k,k,k]                              list a = [ object a ] , list b = [ object b ]
# i = [n,n,n,n,n] k = [a,a,a,a,a]                               object a = [i,i,i,i,i,i] ...
# n = integer, a = integer

при уровне вложенности 3:
    АБ                                                            с подсписком:
# [ object ab ]                                                 [ object ab ]
# object ab = [i,i,i,i,i ]                                      [ list a ],[ list b ]
# i = [n,n,n,n,n,a,a,a,a]                                       list a = [i,i,i,i,i,i,i,i], list b == [k,k,k,k]
# n = integer, a = integer                                      i = [n,n,n,n,n,n], k = [a,a,a,a,a]...

при уровне вложенности 4:
    АБ                                                            с подсписком:
# [ object ab ]                                                 [ object ab ]
# object ab = [i,i,i,i,i]                                       object ab = [i,i,i,i,i ]
# i = [n,a,n,a,n,a,n,a,n]                                       [ list a ],[ list b ]
# n = integer, a = integer                                      list a = [n,n,n,n,n,n], list b = [a,a,a,a,a,a]








РАБОТА СО СПИСКАМИ
Исходные списки:
        А                              Б
# 0 socket data a                   socket data b
# 1 [ object a ]                    [ object b ]
# 2 object a = [i,i,i,i,i ]         object b = [k,k,k,k,k ]
# 3 i = [n,n,n,n,n]                 k = [a,a,a,a,a]
# 4 n = integer                     a = integer

Уровень вложения 1 даёт результат - два объекта в одном списке как если бы они исходили из узла objects. Уровень два соединяет два списка вершин отдельно

Результат:
при уровне вложенности 3 соединяются значения float или int (по умолчанию они на этом уровне находятся в узле objects):
    АБ                              с вложением:                              с смешивателем:
# [ object ab ]                 [ object ab ]                               [ object ab ]
# object ab = [i,i,i,i,i,]      object ab = [list a, list b]                object ab = [i,i,i,i,i ]
# i = [n,n,n,n,n,a,a,a,a]       list a = [i,i,i,], list b == [k,k,k,]       i = [n,a,n,a,n,a]
# n = integer, a = integer      i = [n,n,n], k = [a,a,a]...                 n = integer, a = integer
#                               n = integer, a = integer

    со смешивателем и вложением одновременно:
# [ object ab ]
# object ab = [i,i,i,i]   
# i = list ab      
# list ab == [n,a] ...
# n = integer, a = integer


второй уровень:
[ [ (1,2,3), (4,5,6) ] ] + [ [ (7,8,9), (10,11,12) ] ] = [ [ (1,2,3), (4,5,6), (7,8,9), (10,11,12) ] ]

второй уровень со смешением:
[ [ (1,2,3), (4,5,6) ] ] + [ [ (7,8,9), (10,11,12) ] ] = [ [ (1,2,3),(7,8,9),(4,5,6),(10,11,12) ] ]

второй уровень с вложением:
[ [ (1,2,3), (4,5,6) ] ] + [ [ (7,8,9), (10,11,12) ] ] = [ [ [ (1,2,3),(4,5,6) ], [ (7,8,9),(10,11,12) ] ] ]

второй уровень с вложением и смешением:
[ [ (1,2,3), (4,5,6) ] ] + [ [ (7,8,9), (10,11,12) ] ] = [ [ [ (1,2,3),(7,8,9) ], [ (4,5,6),(10,11,12) ] ] ]

третий уровень:
[ [ (1,2,3), (4,5,6) ] ] + [ [ (7,8,9), (10,11,12) ] ] = [ [ [1,2,3,4,5,6,7,8,9,10,11,12] ] ]

третий уровень со смешением:
[ [ (1,2,3), (4,5,6) ] ] + [ [ (7,8,9), (10,11,12) ] ] = [ [ [1,7,2,8,3,9,4,10,5,11,6,12] ] ]

третий уровень с вложением:
[ [ (1,2,3), (4,5,6) ] ] + [ [ (7,8,9), (10,11,12) ] ] = [ [ [1,2,3,4,5,6],[7,8,9,10,11,12] ] ]

третий уровень с вложением и смешением:
[ [ (1,2,3), (4,5,6) ] ] + [ [ (7,8,9), (10,11,12) ] ] = [ [ [1,7],[2,8],[3,9],[4,10],[5,11],[6,12] ] ]






Сделать батарейки:
    
    решено @бязательно
    1. генератор матрицы. пустая матрица по умолчанию:
        вход векторов положения
        вход векторов масштаба
        вход векторов поворотов
        вход значений поворотов
        выход список матриц
        
    @бязательно
    2. деструктор матриц:
        вход список матриц
        выход вектор положения
        выход вектор масштаба
        выход вектор поворота
        выход значение поворота
    
    @бязательно
    3. деструкторр вектора:
        вход список векторов
        выход координата Х
        выход координата У
        выход координата Й
        простите.
        
    4. генератор сетки точек, уже соеинённых линиями и полигонами:
        вход шаги Х
        вход размер шага Х
        вход шаги У
        вход размер шага У
        выход список векторов
        выход список рёбер
        выход список полигонов
        
    5. выборка из списка по маске индексов:
        вход список
        вводное поле перечисленных индексов, берём конечный уровень - вершины, рёбра или полигоны или матрицы, целиком.
        выход список
        
    6. удаление элементов по индексу:
        вход список
        вводное поле перечисленных индексов, конечный уровень
        выход список
        
    7. вьюверу пришить функцию в виде кнопки object_out, а тот узел удалить.
    
    решено @бязательно
    8. вьюверу в update перенести из условия если нет вершинного сокета строчку вызова дефиниции удаления кеша в условие если есть сокет вертексов, перед обновлением кеша.
    
    9. вьюверу добавить галочку "показывать полигоны как прозрачные"
    
    10. длинна списка:
        вход списка
        выход целое число длинна списка
    
    11. сортировка списка:
        вход список
        галочка сортировка по значению А-Я и наоборот
        галочка сортировка по длине подсписка вершин/рёбер/полигонов
        выход список
    
    12. переворачивание внутри уровней. Сложная схема, наддо думать и уточнять:
        вход список
        выход список
    
    решено @бязательно
    13. доработать деформацию матрицы:
        вход списка векторов на ось вращения
        вход списка дробных чисел для угла поворота
        
    14. создатель рёбер:
        вход список вершин возможно с подуровнями
        галочка поперёк или вдоль
        выход список рёбер
        
    15. создатель полигонов:
        вход список вершин
        вход список рёбер
        вход список маска по индексам рёбер. если нет, используется последовательное соединение
        выход список рёбер
    
    16. переделать вьювер чтобы в него можно было пускать вершины с подуровнями, чтобы он их мог распознавать.
    
    решено @бязательно
    17. то же самое с текстовым вьювером Тогда как бы глубоко не были зарыты
        данные, их всегда можно отрыть	
        и во вьювере прорисовать независимо от вложенности и в текстовом вьювере
        показать количество вложенностей и написать все значения, как они есть, 
        то есть если данные глубже, то не будет всё в одну строчку, а будет
        ==0==0==
        (0,0,0)...
        ==0==1==
        (0,0,0)...
        
    18. поправить в узле node_s то, на что блендер ругается, ID property заменить на RNA property.
    
    @бязательно
    19. Сделать видеоурок-презентацию
    
    решено @бязательно
    20. сделать несколько стандартных схем для расшаривания в сети.
    
    решено 21. подготовить краткую документацию для сверчка 2,0 на сайте помощи, или попросить об этом кого-то. в формате один узел - одно описание, какие входы, какие действия и выходы, как тут мы пишем. копипаст приветствуется.
    
    @бязательно
    22. текст для блендернации подготовить. И красивую картинку, где схема узлов, то что сделано и эмблема сверчка.
    
    @бязательно
    23. 26-27 октября предоставить публике видеоуроки, рассказать на блендернации
    
    24. вьювер сделать возможным вывод отдельно вершин.
    
    25. вьювер текст повесить обновление узла при нажатии кнопки, чтобы что?... ну ладно, повешу.
    
    26. 232 строчка вьювер_дро 
сделай вместо poin так int(point). Ибо ругается на флоат.

    решено @бязательно
    27. сделать прайс на тудушечку.


    28. думаю, при желании можно организовать обновление адона автоматически. то есть кнопка - проверить обновление и если есть обновление, оно пишет что есть новая версия, появляется кнопка "скачать" в панели инструментов и качается версия и автоматически заменяются старые файлы на новые. было бы круто, ящитаю. 

    29. матриц генератор, задаваемый тремя векторами, одним достаточно, другие ортогонально угадываются, длина вектора - масщтаб, положение вектора в пространстве - поворот.

    30. Обновление сокетов - применить везде дефиницию апдейт из утилов

    31. Вьювер дров не показывает точки у второго объекта, а жаль.

    32. генератор по формуле тел, вместе с полигонами и рёбрами на выбор.

    33. генератор сплайнов

    34. нахождение точки на сплайне

    35. узел вычитания и сложения серии векторов, чтобы получать из точки А и точки Б вектор АБ или БА, в зависимости от того, что от чего отнимать.

    36. Множитель вершин по матрицам, чтобы снять с вьювера монополию.

    37. !!!Соединитель списков доработать. Он должен:
	а.Совокуплять последовательно или параллельно
	б.Совокуплять определённый уровень, исключительно этот уровень
	в.Совокуплять с добавлением подуровня над уровнем соединения
	г.комбинировать все эти пункты, то есть оффсет и иннер чек должны иметь одну дефиницию "преобразователь" Зип надо интегрировать в преобразователь для соединителя.



