ТУДУшечка.
дополняется снизу.

Сделать батарейки:
    5. выборка из списка по маске индексов:
        вход список
        вводное поле перечисленных индексов, берём конечный уровень - вершины, рёбра или полигоны или матрицы, целиком.
        выход список
        
    6. удаление элементов по индексу:
        вход список
        вводное поле перечисленных индексов, конечный уровень
        выход список
        
    9. вьюверу добавить галочку "показывать полигоны как прозрачные"
    
    11. сортировка списка:
        вход список
        галочка сортировка по значению А-Я и наоборот
        галочка сортировка по длине подсписка вершин/рёбер/полигонов
        выход список
    
    14. создатель рёбер:
        вход список вершин возможно с подуровнями
        галочка поперёк или вдоль
        выход список рёбер
	срочно доделать!!!!!!!!!!!!!!!
        
    15. создатель полигонов:
        вход список вершин
        вход список рёбер
        вход список маска по индексам рёбер. если нет, используется последовательное соединение
        выход список рёбер
    
    25. вьювер текст повесить обновление узла при нажатии кнопки, чтобы что?... ну ладно, повешу.
    
    надо думать 28. думаю, при желании можно организовать обновление адона автоматически. то есть кнопка - проверить обновление и если есть обновление, оно пишет что есть новая версия, появляется кнопка "скачать" в панели инструментов и качается версия и автоматически заменяются старые файлы на новые. было бы круто, ящитаю. 

    29. матриц генератор, задаваемый тремя векторами, одним достаточно, другие ортогонально угадываются, длина вектора - масщтаб, положение вектора в пространстве - поворот.

    надо думать 30. Обновление сокетов - применить везде дефиницию апдейт из утилов. Для этого изменить структуру передаваемых данных. нужно овладеть кэшем, кэш содержит данные каждого узла каждого сокета. передаётся только имя и фамилия узла через сокеты. Вопрос, как грамотно выстроить дерево обновления всех узлов, чтобы с начала до конца они ишли. иерархия, которая записывается в список? например [сок1, сок10, сок3, сок5, сок2] и в итоге пройдя по сокетам он обновит, но как составить список? На основании иерархии, а как иерархию учесть все уровни. Если несколько веток снова сростаются, например, выйдя из одного узла. или делать несколько списков, пока в списках не будет одинакового имени, и разделить списки до этого имени и после него и соединить между собой, а затем прибавить общий узел и дальше решать, но если есть разветвление любое, то его надо тоже в список как-то запихувать. то есть сначала до разветвления/общего_узла. Похоже что такова логика. при том, есть хаотичный список, перечень всех узлов с сокетами. Линейка в промежуточный список выстраивается по совпадениям имён узлов и сокетов. Так уже три списка, первый - просто перечень, второй - совпадения и фрагменты, третий - попытка соединить всё в одну линию с учётом всех развилок и схождений. как-то так.

    33. генератор сплайнов

    34. нахождение точки на сплайне

    35. узел вычитания и сложения серии векторов, чтобы получать из точки А и точки Б вектор АБ или БА, в зависимости от того, что от чего отнимать.

    36. Множитель вершин по матрицам, чтобы снять с вьювера монополию.

    37. Подумать над кэшем передачи данных. Данные передаются как имя узла и имя текущего дерева узлов. Затем, надо тут же предусмотреть некий центр обновления всего дерева. Спросить у Лукаса Тоена о том, как он решает обновление дерева. Если через кэш, то нужен центр управления, который следит за порядком подключения узлов, а значит отслеживает имя узла, имя узла на входе и так каждый узел, зате5м составляет динамическое дерево и проходя по нему насквозь с начала до конца обновляет все узлы... Как? Это целый комплекс, но работать должно опять же от кнопки апдейт или при каждом "шорохе" делать обновление? Скорее при каждом шорохе обновлять данные отдельных узлов (имена), но не всё дерево, а при нажатии кнопки "обновить" уже обновляет данные из узлов в кэше данных, который суть словарь. Это касается версии 0,3,0, надо будет такую ревизию провести. И обсудить ещё несколько раз.
    
    38. Вместе с тем, надо добавить тип сокета - кривые. Кривая определяется не так как линия, а двумя рычагами и узлом, итого три вектора на точку. Можно сделать кривую как линию, затем сконвертировать и сгладить, автоматически выстроив красивенько. И так и будет генерироваться кривая из векторов. Но как передавать значения? Если мы считаем формулами эту безье, то нам нужны специфические библиотеки, и их надо достать, ибо АПИ не имеет нужных инструментов (нахождение точки на кривой... это проблема, каждый разработчик решает по-своему), и также надо уметь замыкать кривые, а от этого меняется геометрия и нахождение точки на кривой и прочее. Рёбра уже не действуют на кривые, рёбра сокет может быть испольован именно для булена - зациклить или нет. В прочем, если мы все данные переводим в кэш, то можно использовать вектор сокет, оставив тем самым гибкость пользователю. и маркировать в кэше тип данных. Это всё касается версии 0,4,0. 

    39. узел-очиститель списка от нулевых данных, которые получаются при рассечении предварительно рассечённого объекта, так треугольники бывают не замкнутыми или вершины не найдеными, в общем, бывает.
    
    40. остались несколько узлов работы со списками, узел формула 2  и узел деформации матрицы требует дополнительного описания в уроках, это надо сделать.
    
    41. Текстовой просмотрщик при нажатии очищает кэш и кэш не привязан к узлу, не порядок.

    42. Ни центры полигонов ни адаптивные полигоны не работают с более чем одним объектом, это надо менять.

    43. Extrude для выдавливания вход - векторы, полигоны/рёбра, вектор(ы) выдавливания

    44. Объединитель объектов, который бы переназначал индексы вершин для полигонов. чтобы не с нуля, а по порядку.

    45. Просмотрщику установить галочку - активен/неактивен
